<!DOCTYPE html>
<html lang="fr-FR">

<head>
    
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320"><meta property="og:title" content="Loom - Part 3 - Asynchronous code">
<meta property="og:description" content="We&rsquo;ve covered a lot of ground in the previous entries, and we concluded that blocking code &ldquo;is bad&rdquo; ©.
But what can we do about it?">
<meta property="og:type" content="article">
<meta property="og:url" content="https://www.monkeypatch.io/blog/2019/2019-12-23-loom-part-3-async/">

<meta property="og:image" content="https://www.monkeypatch.io/public/images/logos/logo-mkp-blue-x256.png">

<meta property="og:image" content="https://www.monkeypatch.io/images/logos/logo-mkp-head-blue-x126.png">

<meta property="og:image" content="https://www.monkeypatch.io/images/logo-monochrome.svg">
<meta property="article:published_time" content="2019-12-23T18:56:06+01:00">
<meta property="article:modified_time" content="2019-12-23T18:56:06+01:00"><meta property="og:site_name" content="MonkeyPatch">
<meta itemprop="name" content="Loom - Part 3 - Asynchronous code">
<meta itemprop="description" content="We&rsquo;ve covered a lot of ground in the previous entries, and we concluded that blocking code &ldquo;is bad&rdquo; ©.
But what can we do about it?">


<meta itemprop="datePublished" content="2019-12-23T18:56:06&#43;01:00">
<meta itemprop="dateModified" content="2019-12-23T18:56:06&#43;01:00">
<meta itemprop="wordCount" content="2784">



<meta itemprop="keywords" content="java,concurrency,loom,">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://www.monkeypatch.io/public/images/logos/logo-mkp-blue-x256.png">

<meta name="twitter:title" content="Loom - Part 3 - Asynchronous code">
<meta name="twitter:description" content="We&rsquo;ve covered a lot of ground in the previous entries, and we concluded that blocking code &ldquo;is bad&rdquo; ©.
But what can we do about it?">
<meta name="generator" content="Hugo 0.56.3">

<meta name="ROBOTS" content="INDEX, FOLLOW">

<title>MonkeyPatch  | Loom - Part 3 - Asynchronous code</title>


<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">






<link rel="stylesheet" href="https://www.monkeypatch.io/styles/main.62e4def08f0817473ef2abade8bc61175413e8ba5b2b4982c955a6e0a6722ef9.css">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous">

<link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
    
    
    
    

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/themes/prism-tomorrow.min.css" integrity="sha256-4S9ufRr1EqaUFFeM9/52GH68Hs1Sbvx8eFXBWpl8zPI=" crossorigin="anonymous">

</head>

<body class="page blog blog-2019-2019-12-23-loom-part-3-async">

    
    <header>
    
    <div class="menu">
        <div class="logo">
            <a href="https://www.monkeypatch.io/">
                <img alt="Monkey Patch" src="/images/logos/logo-monkey.svg">
            </a>
        </div>

        <nav class="lang">
            <ul>
                
                <li class="active">
                    <a href="https://www.monkeypatch.io/">FR</a>
                </li>
                
                <li class="">
                    <a href="https://www.monkeypatch.io/en/">FR</a>
                </li>
                
            </ul>
        </nav>

        <nav class="menu">
            <ul>
                
                <li class="">
                    <a href="https://www.monkeypatch.io/expert/">Notre Expertise</a>
                </li>
                
                <li class="">
                    <a href="https://www.monkeypatch.io/about/">Notre Philo</a>
                </li>
                
                <li class="">
                    <a href="https://www.monkeypatch.io/careers/">Être Monkeys</a>
                </li>
                
                <li class="">
                    <a href="https://www.monkeypatch.io/jobs/">Nos Jobs</a>
                </li>
                
                <li class="">
                    <a href="https://www.monkeypatch.io/contact/">Contact</a>
                </li>
                
                <li class="">
                    <a href="https://www.monkeypatch.io/blog/">Blog</a>
                </li>
                
            </ul>
        </nav>

        <nav class="hamburger">
            <label for="menu-hamburger">
                <i class="fa fa-bars" aria-hidden="true"></i>
            </label>
        </nav>

    </div>
    <input type="checkbox" id="menu-hamburger">
    <nav class="menu-hamburger">
        <ul>
            
            <li class="">
                <a href="https://www.monkeypatch.io/expert/">Notre Expertise</a>
            </li>
            
            <li class="">
                <a href="https://www.monkeypatch.io/about/">Notre Philo</a>
            </li>
            
            <li class="">
                <a href="https://www.monkeypatch.io/careers/">Être Monkeys</a>
            </li>
            
            <li class="">
                <a href="https://www.monkeypatch.io/jobs/">Nos Jobs</a>
            </li>
            
            <li class="">
                <a href="https://www.monkeypatch.io/contact/">Contact</a>
            </li>
            
            <li class="">
                <a href="https://www.monkeypatch.io/blog/">Blog</a>
            </li>
            
        </ul>
        <ul class="lang">
            
            <li class="active">
                <a href="https://www.monkeypatch.io/">FR</a>
            </li>
            
            <li class="">
                <a href="https://www.monkeypatch.io/en/">FR</a>
            </li>
            
        </ul>
    </nav>
</header>
    

    <main>
        <a id="top"></a>
        

<section class="post">
    <a id="top" name="top"></a>
    <h1>
        <span>Loom - Part 3 - Asynchronous code</span>
    </h1>


    <span class="date">
    December 
    23rd,
    2019
</span>


    <div class="tags">
        
        
        <span>java</span>
        
        <span>concurrency</span>
        
        <span>loom</span>
        
    </div>

    <article><p>We&rsquo;ve covered a lot of ground in the previous entries, and we concluded that blocking code <em>&ldquo;is bad&rdquo; ©</em>.<br>
But what can we do about it?</p>

<blockquote>
<p>Part 3 in a series of articles about Project Loom.<br>
In this part we re-implement our proxy service with an asynchronous API.</p>

<p>The companion code repository is at <a href="https://github.com/arnaudbos/untangled">arnaudbos/untangled</a></p>

<p>If you&rsquo;d like you could head over to<br>
<a href="../2019-12-14-loom-part-0-rationale">Part 0 - Rationale</a><br>
<a href="../2019-12-14-loom-part-1-scheduling">Part 1 - It&rsquo;s all about Scheduling</a><br>
<a href="../2019-12-18-loom-part-2-blocking">Part 2 - Blocking code</a><br>
<a href="../2019-12-23-loom-part-3-async">Part 3 - Asynchronous code</a> (this page)<br>
<a href="../../2020/2020-05-08-loom-part-4-nio">Part 4 - Non-thread-blocking async I/O</a></p>
</blockquote>


<figure style="text-align: center;">
    
        <img src="https://i-rant.arnaudbos.com/img/loom/handweaving.jpg" alt="Seamstresses in a shop" width="70%">
    
    
    <figcaption>
        <h6><em>Seamstresses in a shop</em></h6>
        
    </figcaption>
    
</figure>



<hr>

<p>While researching, I&rsquo;ve read many blog posts presenting <code>asynchronous</code> programming
as a solution. It makes sense: our kernels use preemptive scheduling. So there&rsquo;s nothing to do when the scheduler
time-slices a long-running thread. But we <strong>can</strong> maximize efficiency! By <em>being
careful</em> to avoid blocking calls and use asynchronous APIs.</p>

<p>We will write code that, instead of blocking, will call an async API. This call will return the control of execution
immediately (so we can execute other instructions) and only notify us when the result is ready.</p>

<p>Let&rsquo;s take a look at the second implementation I&rsquo;ve made of the proxy service I&rsquo;ve presented in the <a href="../2019-12-18-loom-part-2-blocking">previous entry</a>.</p>

<p>You can find the complete source code for this sample <a href="https://github.com/arnaudbos/untangled/blob/master/hawaii/src/main/java/io/monkeypatch/untangled/Chapter02bis_ScheduledFully.java">here</a>.</p>

<h2 id="async-api">Async API</h2>

<p>Changing an API from synchronous to asynchronous seems simple at first.<br>
From the inner out, we create a new function, <code>asyncRequest</code>, as an asynchronous alternative to
<code>blockingRequest</code>.</p>

<pre><code class="language-java">public void asyncRequest(ExecutorService, String, String, CompletionHandler)
</code></pre>

<p><em>asyncRequest</em> has to return immediately to not block the calling thread, so we give it an
<code>ExecutorService</code>. This also benefits us, by being explicit about which pool is used.
It also takes a <em>String</em> for the URL, another for the headers, and also a <code>CompletionHandler</code>.<br>
<em>CompletionHandler</em> is an interface one has to implement. Its methods are called by <em>asyncRequest</em>
once the result of the request is available: one callback in case of success, another in case of error.</p>

<pre><code class="language-java">public interface CompletionHandler&lt;V&gt; {
    void completed(V result);
    void failed(Throwable t);
}
</code></pre>

<p>I&rsquo;ll spare you the request details hidden inside the intermediary
<code>CoordinatorService#requestConnection(String, CompletionHandler, ExecutorService)</code>. Instead, let&rsquo;s get to the new version
of <code>getConnection</code> we&rsquo;ve talked about in the previous entry:</p>

<pre><code class="language-java">private void getConnection(CompletionHandler&lt;Connection.Available&gt; handler) {
    getConnection(0, 0, null, handler);
}

private void getConnection(long eta,
                           long wait,
                           String token,
                           CompletionHandler&lt;Connection.Available&gt; handler)
{
    if (eta &gt; MAX_ETA_MS) {
        if (handler!=null) handler.failed(new EtaExceededException());
    }

    boundedServiceExecutor.schedule(() -&gt; {
        println(&quot;Retrying download after &quot; + wait + &quot;ms wait.&quot;);

        coordinator.requestConnection(
            token,
            new CompletionHandler&lt;&gt;() {
                // ... We'll see this later
            },
            boundedServiceExecutor);
    }, wait, TimeUnit.MILLISECONDS);
}
</code></pre>

<p>The signatures are like the synchronous ones, except for the extra <code>CompletionHandler&lt;Connection.Available&gt;</code>
handler.<br>
But instead of making the request, we <code>schedule</code> it to the <code>boundedServiceExecutor</code>.</p>

<p><em>boundedServiceExecutor</em> is an instance of <code>ScheduledThreadPoolExecutor</code>.</p>

<pre><code class="language-java">boundedRequestsExecutor =
    Executors.newScheduledThreadPool(10, new PrefixedThreadFactory(&quot;requests&quot;));
</code></pre>

<p>In fact, <em>boundedServiceExecutor</em> is not the only thread pool used in this implementation.<br>
To make things explicit about where each task runs, I&rsquo;ve created 3 dedicated executors:</p>

<pre><code class="language-java">// One from which service methods are called and coordinator requests are sent
boundedServiceExecutor =
    Executors.newScheduledThreadPool(10, new PrefixedThreadFactory(&quot;service&quot;));
// One from which gateway (download) requests are sent
boundedRequestsExecutor =
    Executors.newScheduledThreadPool(10, new PrefixedThreadFactory(&quot;requests&quot;));
// One from which heartbeat resquests are scheduled
boundedPulseExecutor =
    Executors.newScheduledThreadPool(10, new PrefixedThreadFactory(&quot;pulse&quot;));
</code></pre>

<blockquote>
<p>Note that both <code>boundedServiceExecutor</code> and <code>boundedRequestsExecutor</code> could have been instances of
<code>ThreadPoolExecutor</code> (using <code>Executors#newFixedThreadPool(int, ThreadFactory)</code>)<br>
rather than <code>ScheduledThreadPoolExecutor</code>;<br>
because only heartbeat requests (using <code>boundedPulseExecutor</code>) must be delayed.<br>
But both being fix-sized pools, the result is the same.</p>
</blockquote>

<p>Like the synchronous example, <code>getConnection</code> deals with the retry logic. But
<code>CoordinatorService#requestConnection</code> is asynchronous and takes a <em>CompletionHandler</em>, because it calls to
<code>asyncRequest</code>. So we have to implement both success and error callback methods.</p>

<pre><code class="language-java">new CompletionHandler&lt;&gt;() {
    @Override
    public void completed(Connection c) {
        if (c instanceof Connection.Available) {
            if (handler!=null)
①              handler.completed((Connection.Available) c);
        } else {
②          Connection.Unavailable unavail = (Connection.Unavailable) c;
            getConnection(
                unavail.getEta(),
                unavail.getWait(),
                unavail.getToken(),
                handler);
        }
    }
    @Override
③  public void failed(Throwable t) {
        if (handler!=null) handler.failed(t);
    }
}
</code></pre>

<ol>
<li>In case of <code>Available</code>, we&rsquo;re done; we can complete the completion <em>handler</em> passed to <code>getConnection</code>. Its caller can
be notified of the success and proceed (with the download).</li>
<li>In case of <code>Unavailable</code>, we hide the retry logic and <em>reschedule</em> the call to <em>requestConnection</em> to the executor
by recursively calling <code>getConnection</code> with updated parameters.</li>
<li>In case of failure we simply propagate the error to <code>getConnection</code>&rsquo;s caller.</li>
</ol>

<p>The callbacks already make this logic cluttered enough; but we&rsquo;re not done! We must now implement <code>getThingy</code>, our
service method which calls to <code>getConnection</code> and then start the download request.</p>

<pre><code class="language-java">private void getThingy(int i, CompletionHandler&lt;Void&gt; handler) {
    println(&quot;Start getThingy.&quot;);

①  getConnection(new CompletionHandler&lt;&gt;() {
        @Override
②      public void completed(Connection.Available conn) {
            println(&quot;Got token, &quot; + conn.getToken());

            CompletableFuture&lt;Void&gt; downloadFut = new CompletableFuture&lt;&gt;();
③          gateway.downloadThingy(new CompletionHandler&lt;&gt;() {
                @Override
④              public void completed(InputStream content) {
                    // Download started
                }

                @Override
⑥              public void failed(Throwable t) { ... }
⑤          }, boundedServiceExecutor);

        }

        @Override
⑥      public void failed(Throwable t) { ... }
    });
}
</code></pre>

<ol>
<li>We&rsquo;ve seen above that <code>getConnection</code> takes a completion handler.</li>
<li>Its <code>complete</code> method will be called when we successfully get a download authorization from the coordinator.</li>
<li>On <em>successful</em> completion, the download starts, which materializes by calling <code>gateway.downloadThingy</code>.
<code>downloadThingy</code> is, itself, asynchronous because it also calls down to <code>asyncRequest</code>, so we must give it a new
<em>CompletionHandler</em>.</li>
<li>This completion handler is passed an <code>InputStream</code> once we connect to the data source. We
can then read the content and forward it to this service&rsquo;s client. The consumption of the <em>InputStream</em> and
forwarding to the client is omitted for now and replaced by the &ldquo;Download started&rdquo; comment.</li>
<li><code>downloadThingy</code>&rsquo;s last parameter is an optional executor, used to specify which pool is used to run the completion
handler. If omitted, it is the calling thread, but in this case, we specify that we want the content
consumption/forwarding to happen on the <code>boundedServiceExecutor</code>.</li>
<li>In case of failure from <code>getConnection</code> or <code>downloadThingy</code>, we complete <code>getThingy</code>&rsquo;s completion handler with a
failure.</li>
</ol>

<p>Now that we have the structure, we can handle the content, but also start the periodic heartbeat requests!</p>

<pre><code class="language-java">    Runnable pulse = new PulseRunnable(i, downloadFut, conn);
    int total = 0;
①  try(content) {
        println(i + &quot; :: Starting pulse &quot;);
②      boundedPulseExecutor.schedule(pulse, 2_000L, TimeUnit.MILLISECONDS);
    
        // Get read=-1 quickly and not all content
        // because of HTTP 1.1 but really don't care
        byte[] buffer = new byte[8192];
③      while(true) {
            int read = content.read(buffer);
            // drop it
            if (read==-1 || (total+=read)&gt;=MAX_SIZE) break;
        }
    
        println(&quot;Download finished&quot;);
    
        if (handler!=null)
④          handler.completed(null);
    } catch (IOException e) {
        err(&quot;Download failed.&quot;);
        if (handler!=null)
④          handler.failed(e);
    } finally {
⑤      downloadFut.complete(null);
    }
</code></pre>

<p>Remember this code executes inside <code>downloadThingy</code>&rsquo;s completion handler, so when this code runs, the connection
to the data source is established.</p>

<ol>
<li>We encapsulate the logic inside a <code>try-with-resource</code> block around <code>content</code> (the <em>InputStream</em>) because it can
fail at any moment.</li>
<li>We&rsquo;ve initialized a <code>PulseRunnable</code>, which we can now schedule to send heartbeat requests. It will reschedule itself
upon completion. The reference to the <em>Future</em> <code>downloadFut</code> allows to stop sending heartbeats
when the download ends. We&rsquo;ll see <code>PulseRunnable</code> later.</li>
<li>In the mean time, we consume the <em>InputStream</em> and just ignore the content once again (not important).</li>
<li>Finally, when the download stops, on success or on error, we <em>complete</em> <code>getThingy</code>&rsquo;s handler accordingly.</li>
<li>We don&rsquo;t forget to complete <code>downloadFut</code> either, so the heartbeats stop.</li>
</ol>

<p>Almost done. We now look at <code>PulseRunnable</code>:</p>

<pre><code class="language-java">class PulseRunnable implements Runnable {
    private int i;
    private Future&lt;Void&gt; download;
    private Connection.Available conn;

    PulseRunnable(int i, Future&lt;Void&gt; download, Connection.Available conn) {
        this.i = i;
        this.download = download;
        this.conn = conn;
    }

    @Override
    public void run() {
        if (!download.isDone()) {
            println(i + &quot; :: Pulse!&quot;);
①          coordinator.heartbeat(
                conn.getToken(),
                new CompletionHandler&lt;&gt;() {
                    ...
                },
                boundedPulseExecutor
            );
        } else {
            println(i + &quot; :: Pulse stopped.&quot;);
        }
    }
}
</code></pre>

<ol>
<li><p>When started, the runnable calls the asynchronous <code>CoordinatorService#heartbeat</code> method with the token,
<em>completion handler</em> and executor. The executor is responsible to run the handler&rsquo;s methods (<code>boundedServiceExecutor</code> in
this case, like when calling <code>GatewayService#downloadThingy</code> above).</p>

<pre><code class="language-java">coordinator.heartbeat( // See previous snippet
conn.getToken(),
new CompletionHandler&lt;&gt;() {
    @Override
②      public void completed(Connection result) {
③          rePulseIfNotDone();
    }
    
    @Override
②      public void failed(Throwable t) {
③          rePulseIfNotDone();
    }
},
boundedPulseExecutor
);
</code></pre></li>
</ol>

<ol start="2">
  <li>We ignore heartbeat results, whether successes or failures,</li>
  <li>And schedule a new heartbeat request as long as the download <i>Future</i> is not "done".</li>
</ol>

<pre><code>The code for `rePulseIfNotDone`.
```java
private void rePulseIfNotDone() {
    if (!download.isDone()) {
        boundedServiceExecutor.schedule(
            PulseRunnable.this,
            2_000L,
            TimeUnit.MILLISECONDS
        );
    }
}
```
</code></pre>

<p>Finally, the last piece of the puzzle: clients calling the service:</p>

<pre><code class="language-java">CompletableFuture&lt;Void&gt;[] futures = new CompletableFuture[MAX_CLIENTS];
for(int i=0; i&lt;MAX_CLIENTS; i++) {
    int finalI = i;
    futures[i] = new CompletableFuture&lt;&gt;();
    getThingy(finalI, new CompletionHandler&lt;&gt;() {
        @Override
        public void completed(Void result) {
            futures[finalI].complete(result);
        }

        @Override
        public void failed(Throwable t) {
            futures[finalI].completeExceptionally(t);
        }
    });
}
</code></pre>

<p>Phew&hellip;</p>

<p>That certainly wasn&rsquo;t easy code. Not like the synchronous code we&rsquo;ve seen in the <a href="../2019-12-18-loom-part-2-blocking">previous entry</a>! The problem
is still simple though, so it tells a lot about asynchronous programming: it&rsquo;s a <strong>massive  pain in the butt</strong>.</p>

<p>The logic is all over the place! Asynchronous APIs forces us to split our logic into pieces, but not the pieces we&rsquo;d
like. A perfectly self-contained function in synchronous programming would have to be split into two to three (if not more)
callbacks and suddenly it&rsquo;s not easy to reason about the code anymore.<br>
This problem has a name: <strong><a href="http://callbackhell.com/">Callback Hell</a></strong> (and no, it&rsquo;s not just JavaScript, I mean just look at the code above).</p>

<h2 id="profiling">Profiling</h2>

<p>If async is the answer to write efficient services that make the most out of server resources, maybe it&rsquo;s worth the
pain!</p>

<p>Profiling this code revealed that CPU usage was still low, more or less like in the previous implementation.
Threads are more interesting:</p>


<figure style="text-align: center;">
    
        <img src="https://i-rant.arnaudbos.com/img/loom/impl2-threads.png" alt="Not too many threads" width="70%">
    
    
    <figcaption>
        <h6><em>Not too many threads</em></h6>
        
    </figcaption>
    
</figure>



<p>200 clients, 30 threads, everything is proceeding as I have foreseen. But wait&hellip; this is very slow!<br>
This screenshot shows only the first minute of runtime and then the rest of the chart looks the same.</p>

<p>The previous implementation created a bunch of threads but at least finished quickly, in less than a minute.<br>
Why is it so slow?</p>

<p><a href="https://visualvm.github.io/">VisualVM</a> to the rescue:</p>


<figure style="text-align: center;">
    
        <img src="https://i-rant.arnaudbos.com/img/loom/impl2-threads-running.png" alt="Three thread pools" width="70%">
    
    
    <figcaption>
        <h6><em>Three thread pools</em></h6>
        
    </figcaption>
    
</figure>



<p>Let&rsquo;s refer to the implementation to find what threads, from each thread pool (<code>request</code>, <code>pulse</code> and <code>service</code>)
is doing what.</p>

<h3 id="request-threads">Request threads</h3>

<p>Threads whose names begin with <code>request</code> come from <code>boundedRequestsExecutor</code>. The only place where this <em>Executor</em> is
used is inside <code>downloadThingy</code>, which I had omitted before. Here it is:</p>

<pre><code class="language-java">class GatewayService {
    void downloadThingy(CompletionHandler&lt;InputStream&gt; handler,
                        ExecutorService handlerExecutor)
{
①  asyncRequest(
        boundedRequestsExecutor,
        &quot;http://localhost:7000&quot;,
        String.format(HEADERS_TEMPLATE, &quot;GET&quot;, &quot;download&quot;, &quot;text/*&quot;, String.valueOf(0)),
        new CompletionHandler&lt;&gt;() {
            @Override
            public void completed(InputStream result) {
                if (handler != null)
                    if (handlerExecutor!=null) {
                        handlerExecutor.submit(
                          () -&gt; handler.completed(result)
                        );
                    } else {
                        handler.completed(result);
                    }
            }

            @Override
            public void failed(Throwable t) {
                if (handler != null)
                    if (handlerExecutor!=null) {
                        handlerExecutor.submit(
                            () -&gt; handler.failed(t)
                        );
                    } else {
                        handler.failed(t);
                    }
            }
        });
    }
}
</code></pre>

<p>The code of <code>asyncRequest</code> is secret sauce for the moment, suffice to say that the executor it is given
(<code>boundedRequestsExecutor</code> in this case) serves only to call its <code>submit(Runnable)</code> method.</p>

<p>So the <code>request-*</code> threads in the VisualVM screenshot above are all doing the same thing: execute an <code>asyncRequest</code>
and pass the result to whoever the caller is.</p>

<h3 id="pulse-threads">Pulse threads</h3>

<p>Threads whose names begin with <code>pulse</code> come from <code>boundedPulseExecutor</code>. The only places where this <em>Executor</em> is
used is when scheduling the heartbeat requests, from within <code>getThingy</code> and from the &ldquo;pulse&rdquo; <em>Runnable</em> itself:</p>

<p><code>boundedPulseExecutor.schedule(pulse, 2_000L, TimeUnit.MILLISECONDS);</code></p>

<p>It is also given as the last parameter to <code>CoordinatorService#heartbeat</code> to execute its <em>completion
handler</em>:</p>

<pre><code class="language-java">@Override
public void completed(InputStream is) {
    Runnable r = () -&gt; {
        if (handler != null)
            handler.completed(parseToken(() -&gt; is));
    };
    if (handlerExecutor!=null) {
        handlerExecutor.submit(r);
    } else {
        r.run();
    }
}
</code></pre>

<p>So the <code>pulse-*</code> threads, in the VisualVM screenshot above, are doing small things too: execute a heartbeat
<code>asyncRequest</code> and a bit of <code>parseToken</code>, which consists in decoding a few bytes.</p>

<h3 id="service-threads">Service threads</h3>

<p>Threads whose names begin with <code>service</code> come from <code>boundedServiceExecutor</code> and are used in several places.</p>

<ul>
<li>in <code>getConnection</code>, to submit the call to <code>CoordinatorService#requestConnection</code></li>
<li>to execute the <em>completion handler</em> of <code>CoordinatorService#requestConnection</code></li>
<li>to execute the <em>completion handler</em> of <code>GatewayService#downloadThingy</code></li>
<li>to execute the calls to <code>asyncRequest</code> inside <code>CoordinatorService#requestConnection</code> and <code>CoordinatorService#heartbeat</code></li>
</ul>

<p>So the <code>service-*</code> threads in the VisualVM screenshot above are doing a few asynchronous calls and also a bit of
callback execution.</p>

<h3 id="a-word-about-scheduledthreadpoolexecutor">A word about ScheduledThreadPoolExecutor</h3>

<p>It&rsquo;s time to introduce the <code>ScheduledThreadPoolExecutor</code>.</p>

<p>Contrary to cached <code>ThreadPoolExecutor</code>, it doesn&rsquo;t spawn new threads to keep up with the number of <em>Runnable</em>.
Instead, it stays with the number of threads it is passed when created.</p>


<figure style="text-align: center;">
    
        <img src="https://i-rant.arnaudbos.com/img/loom/async-all-the-things.png" alt="Async all the things!" width="70%">
    
    
    <figcaption>
        <h6><em>Async all the things!</em></h6>
        
    </figcaption>
    
</figure>



<p>Each thread runs an infinite loop, executing <em>Runnable</em> after <em>Runnable</em> from the executor&rsquo;s tasks queue. When
using this kind of executor, the goal is to execute non-blocking calls. Blocking calls suspend the thread until
the result of the call is available. Executing a blocking call on such thread would suspend it and prevent
it from executing the next tasks from the queue!</p>

<p>As seen in <a href="../2019-12-18-loom-part-2-blocking">Part 2</a>, we want to avoid blocking calls. Especially with this kind of executor, because
it becomes possible to bring the whole application to a halt!</p>

<p>Fortunately, our whole implementation is asynchronous! Every method of our service submits tasks to an executor
and there are callbacks all over the place.</p>

<h2 id="beware-of-the-lurking-blocking-call">Beware of the lurking blocking call</h2>

<p>We now have a bit more context on what each thread does. Let&rsquo;s take <strong>another</strong> look at the VisualVM screenshot:</p>


<figure style="text-align: center;">
    
        <img src="https://i-rant.arnaudbos.com/img/loom/impl2-threads-running.png" alt="&#34;Service&#34; thread pool&#39;s threads are busy" width="70%">
    
    
    <figcaption>
        <h6><em>&#34;Service&#34; thread pool&#39;s threads are busy</em></h6>
        
    </figcaption>
    
</figure>



<p>The <code>request-*</code> and <code>pulse-*</code> threads spend most of their time <code>parked</code>.</p>

<p>Each thread in those pools looks for tasks to execute (<em>runnables</em>) coming down the executor&rsquo;s queue.
Because the only tasks submitted to them are asynchronous, their execution are quick! Soon, the
queue is drained and there&rsquo;s nothing to do. The executor will thus park the threads.</p>

<p>The <code>service-*</code> threads, however, spend all their time running. And it is as weird as in the previous entry:
we&rsquo;ve supposed to execute only asynchronous methods and compute nothing. I&rsquo;ll spare you the thread dump, let&rsquo;s
jump to the <a href="http://www.brendangregg.com/flamegraphs.html">flame graph</a>:</p>


<figure style="text-align: center;">
    
        <img src="https://i-rant.arnaudbos.com/img/loom/impl2-flame.png" alt="Bummer!" width="70%">
    
    
    <figcaption>
        <h6><em>Bummer!</em></h6>
        
    </figcaption>
    
</figure>



<p><strong>There&rsquo;s a blocking call lurking in a dark corner of our &ldquo;beautiful&rdquo; asynchronous API!</strong></p>

<p>And if you didn&rsquo;t see it coming, maybe you understand why I didn&rsquo;t show the code of <code>asyncRequest</code> before.
Let&rsquo;s look:</p>

<pre><code class="language-java">public static void asyncRequest(ExecutorService executor,
                                String url,
                                String headers,
                                CompletionHandler&lt;InputStream&gt; handler)
{
    executor.submit(() -&gt; {
        try {
            InputStream is = blockingRequest(url, headers);
            if (handler!=null)
                handler.completed(is);
        } catch (Exception e) {
            if (handler!=null)
                handler.failed(e);
        }
    });
}
</code></pre>

<p style="width: 100%; text-align: center;"><i>"Mischief managed"</i></p>

<p>Under the hood, <code>asyncRequest</code> calls down to <code>blockingRequest</code> and its blocking <code>SocketChannel</code>/<code>InputStream</code>!
The reason why the <code>service-*</code> threads look busy is that they are actually blocked.</p>

<p>Previously, I&rsquo;ve asked: &ldquo;Why is it so slow?&rdquo;. The answer is: because those threads are from a pool managed by a
fixed-size <code>ScheduledThreadPoolExecutor</code>, on top of which no more than 10 simultaneous requests can be running.
The threads being blocked, they prevent other tasks submitted to the executor from running.</p>


<figure style="text-align: center;">
    
        <img src="https://i-rant.arnaudbos.com/img/loom/still-thread-blocking.png" alt="Still thread-blocking" width="70%">
    
    
    <figcaption>
        <h6><em>Still thread-blocking</em></h6>
        
    </figcaption>
    
</figure>



<p>Thus, the net effect of changing this API from synchronous to asynchronous has been a latency increase. Because the
jobs keep piling up in the executor&rsquo;s queue! We&rsquo;re, in effect, limited our parallelism.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Some blog posts present asynchronous programming as a solution to the problem of scaling a service. This bothers me.</p>

<p>They often use <code>asynchronous</code> in opposition to <code>blocking</code>. However, the opposite of <em>blocking</em> is <code>non-blocking</code>, not
<em>asynchronous</em>. Using <em>non-blocking</em> alone conflates not blocking the <strong><em>current thread</em></strong> with not blocking <strong><em>any thread</em></strong>.
<em>Non-blocking</em> does noot equate <em>non-thread-blocking</em>!</p>

<p>As seen above, using an asynchronous API doesn&rsquo;t mean anything about its thread-blocking properties.
An asynchronous call submitted to an executor doesn&rsquo;t block the current thread, for sure, but it may very well block
the thread it is running on! This is usually where you read comments such as &ldquo;use a dedicated thread pool&rdquo;.<br>
Indeed, you want to dedicate a thread pool for those blocking calls to avoid impacting the rest of your application.
But you&rsquo;re left with two choices. Either use an unbounded thread pool, risking unpredictable behaviour, or use a bounded
one, risking increased latency for those tasks.</p>

<p>I prefer to think about <em>blocking</em> and <em>non-blocking</em> as runtime properties. Likewise, I much prefer using <em>asynchronous</em>
as opposed to <em>synchronous</em> when talking about an API or <em>programming style</em>. <strong>Conflating sync/async as
thread-blocking/non-thread-blocking is a source of confusion.</strong> In fact, both are orthogonal.</p>

<p>But there&rsquo;s a reason why both are often mixed-up: today, the only—i.e. built-in— way to execute <code>non-thread-blocking</code>
code <em>on the JVM</em> is to use <code>asynchronous</code> API.</p>

<p>In the <a href="../../2020/2020-05-08-loom-part-4-nio">next part</a>, we&rsquo;ll re-implement <code>asyncRequest</code> to be truly non-blocking.</p>

<h2 id="post-scriptum">Post Scriptum</h2>

<p>Writing asynchronous code is hard.</p>


<figure style="text-align: center;">
    
        <img src="https://i-rant.arnaudbos.com/img/loom/vegeta.png" alt="It&#39;s over 800!" width="70%">
    
    
    <figcaption>
        <h6><em>It&#39;s over 800!</em></h6>
        
    </figcaption>
    
</figure>



<p>On the left a peak to 122 live threads when I did a small mistake. On the right a peak to more that 800 live threads
when I messed up on purpose to see the result (I swear!).</p></article>

    <div class="authors">
        
        <div class="author">
            <a href="https://twitter.com/arnaud_bos" rel="author">
                <img src="https://ca.slack-edge.com/T1H5KD6N6-U30C1P23G-a63601ba6c7d-512" alt="Arnaud bos">
                <span>Arnaud bos</span>
            </a>
        </div>
        
    </div>
</section>


<div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "monkeypatchblog" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>




        
        <footer class="top">
    <div>
      <h3>Rester en contact</h3>
      <p>
        <a class="contact icon-map" href="/contact">
          <i class="fa fa-map-marker" aria-hidden="true"></i>
          <img src="/images/icons/Toulouse.png" alt="Toulouse">
        </a>
      </p>
      <p>
        <i class="fa fa-envelope-o" aria-hidden="true"></i>
        <a class="mail" href="mailto:contact@monkeypatch.io">contact@monkeypatch.io</a>
      </p>
    </div>
    <div class="social-network">
      <h3>Réseaux sociaux</h3>
      <ul class="social">
        <li>
          <a href="https://twitter.com/monkeypatch_io">
            <i class="fa fa-twitter" aria-hidden="true"></i>
          </a>
        </li>
        <li>
          <a href="https://www.linkedin.com/company/monkeypatch-io">
            <i class="fa fa-linkedin" aria-hidden="true"></i>
          </a>
        </li>
      </ul>
    </div>
  
</footer>

<footer class="bottom">
  <div>
    Copyright @ 2019 MonkeyPatch -<a href="/terms">Termes et conditions</a>
  </div>
  <div>
    Made with <i class="fa fa-heart" aria-hidden="true"></i> In Toulouse
  </div>
  <a class="goToTop" href="#top">
    <i class="fa fa-caret-up" aria-hidden="true"></i>
  </a>
</footer>

        
    </main>


<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-KGGFWH');</script>


<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KGGFWH" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

    <script src="/scripts/modernizr-custom.js"></script>
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/prism.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/components/prism-haskell.min.js" integrity="sha256-MxfNlM5EW2pm9DZPWGvreAHxKNF8NK8DaLSVVtG+MjE=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/components/prism-clojure.min.js" integrity="sha256-eGVrzVqJ/GigoW8fpafNd5j00+zIESDj7FeJcrBUlrA=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/components/prism-kotlin.min.js" integrity="sha256-BLmzS+mVDv8mg8ciLO7Lxoz1vAYhFtyboFOT0EMY+lg=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/components/prism-c.min.js" integrity="sha256-POQgKdZt7XGlcjT5opjx6fXs/Pt4eao8x7Q8JRaa/1A=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/components/prism-brainfuck.min.js" integrity="sha256-VMnAWpm0qsoKYhwjGWpbpIFoEqmKFqgRMvrsPe4SLA8=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/components/prism-lolcode.js" integrity="sha256-GfPLGNDlIwgQKINyzfQdNvX/cI3Pm9/4nQRGez7eMtc=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/components/prism-typescript.min.js" integrity="sha256-m2ghaPy1JKNwDlCG/ObigLWw9/7qGHvUhoXp6odkcTI=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/components/prism-json.min.js" integrity="sha256-oA5rMHeAX+cg/CdcQ0VHmIqqw/IW4o2KAUEjo4QvShs=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/components/prism-yaml.min.js" integrity="sha256-pxsoS7PqPuy6D5T0Dq2PEXKJ5SRlIkdG8hpoMxQ0YlM=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/components/prism-java.min.js" integrity="sha256-4jBV//QjNNXvyK55J0R2NwTbl2SAzk/4DHBynIhrxWQ=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.20.0/components/prism-rust.min.js" integrity="sha512-a+IgkN5sZbEosACcEWe/sM44yttZ31//JRCMMJ/iJvFqyMf5BFDTwClDikRSq9IFNCF5arl3VXl+43PIh+z77A==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.20.0/components/prism-toml.min.js" integrity="sha512-nR+DujZm33eiRbZSfMapBdGw+1a8yQCknJxCkdSqxWunDODhOv35GVaU1zUM1vqO0iHL86LRV9EGNi7EkjSFkw==" crossorigin="anonymous"></script>


<script>
Array.from(document.querySelectorAll(".post article [id]"))
    .forEach(function (elt) {
        var id = elt.getAttribute("id");
        var content = elt.textContent;
        elt.innerHTML = '<a class="anchor" href="#' + id + '">' + content + '</a>';
    });
</script>

<script>
    window.twttr = (function (d, s, id) {
        var js, fjs = d.getElementsByTagName(s)[0],
            t = window.twttr || {};
        if (d.getElementById(id)) return t;
        js = d.createElement(s);
        js.id = id;
        js.src = "https://platform.twitter.com/widgets.js";
        fjs.parentNode.insertBefore(js, fjs);

        t._e = [];
        t.ready = function (f) {
            t._e.push(f);
        };

        return t;
    }(document, "script", "twitter-wjs"));
</script>

</body>

</html>